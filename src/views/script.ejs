let homeTabData = {};
let groupForm, bookmarkForm, dropAreaForm;
let messageTimer;
let forceOpenInNewTab = false;
const editingMemo = [];  // [index, name/label, url, thumbnail]
let apikey, rememberGroupIndex, openInNewTab, autoDismissTimeframe, maxBookmarkPerRow, uploadBuffer, bookmarkSpace;
const settingsMenuItem = ['general', 'appearance', 'data-management', 'api-key', 'about'];

const qs = (selector, all = false) => {
    return (typeof selector === 'string' ? (!all ? document.querySelector(selector) : document.querySelectorAll(selector)) : selector);
};

const attr = (selector, arrtProps) => {
    const obj = qs(selector);
    for (const prop in arrtProps) {
        obj.setAttribute(prop, arrtProps[prop]);
    }
};

const html = (selector, content = '') => {
    qs(selector).innerHTML = content;
};

const create = (tag, ...props) => {
    const obj = document.createElement(tag);
    const [content, classname, attributes] = props;
    if (attributes !== undefined) {
        for (const attr in attributes) {
            obj.setAttribute(attr, attributes[attr]);
        }
    }
    content !== undefined && content !== '' && (obj.innerHTML = content);
    classname !== undefined && (obj.className = classname);
    return obj;  
};

const setDragStartState = obj => {
    addClass(obj, 'drag-start-state');
};

const setDragEndState = obj => {
    removeClass(obj, 'drag-start-state');
};

const setGruopVisibility = () => {
    const groups = homeTabData.groups;
    const menuIconX = getBoundingProps('.app-menu-icon').x;
    const hiddenGroups = [];
    const addGropuObj = qs('.add-new-group');
    if (getBoundingProps(addGropuObj).right > menuIconX) {
        addClass(addGropuObj, 'group-visibility-hidden');
        hiddenGroups.push(addGropuObj);
    }
    else {
        removeClass(addGropuObj, 'group-visibility-hidden');
    }
    groups.forEach((group, index) => {
        const groupObj = qs(`#group${index}`);
        const groupObjProps = getBoundingProps(groupObj);
        if (groupObjProps.right > menuIconX) {
            addClass(groupObj, 'group-visibility-hidden');
            hiddenGroups.push(groupObj);
        }
        else {
            removeClass(groupObj, 'group-visibility-hidden');
        }
    });
    renderAppMenuContent(hiddenGroups);
};

const getBoundingProps = selector => {
    return qs(selector).getBoundingClientRect();
};

const setValue = (selector, value = '') => {
    qs(selector).value = value;
};

const getValue = selector => {
    return qs(selector).value;
};

const setFormValues = (form, values = []) => {
    const inputs = Array.from(form.childNodes).filter(child => child.tagName == 'INPUT' && child.type.match(/hidden|text/i));
    inputs.forEach((input, index) => input.value = values[index]);    
};

const getFormValues = form => {
    const values = [];
    const inputs = Array.from(form.childNodes).filter(child => child.tagName == 'INPUT' && child.type.match(/hidden|text/i));
    inputs.forEach(input => values.push(input.value));
    return values;
};

const downloadDataFile = data => {
    const dataString = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(data));
    const exportDataAnchor = create('a', '', '', {
        href: dataString,
        download: 'home-tab-bookmark-data.json'
    });
    exportDataAnchor.click();
};

const getDataFromServer = event => {
    fetch('/get-data/')    
    .then(resp => resp.json())
    .then(data => {
        if (isHomeTabBookmarkData(data.home_tab_data)) {
            if (event) {
                homeTabData = data.home_tab_data;
                doneInit();
            }
            else {
                downloadDataFile(data);
            }
        }
        else {
            showMessagePopup('Data corrupted, try import data from backup file.');
        }
    })
    .catch(error => {
        showMessagePopup('Error while retrieving data, please try again later.');
    });
};

const setDataToServer = async () => {
    if (isHomeTabBookmarkData(homeTabData)) {
        homeTabData.timestamp = Date.now();
        homeTabData.version = version;
        const formData = new FormData();
        formData.append('home_tab_data', `{"home_tab_data":${JSON.stringify(homeTabData)}}`);
        return await fetch('/set-data/', {
            method: 'POST',
            header: {'Content-Type': 'multipart/form-data'},
            body: formData
        })
        .catch(error => {
            showMessagePopup('Error while retrieving data, please try again later.');
        }); 
    }
    else {
        showMessagePopup('Data may have corrupted, please try import data from backup file.');
    }
};

const setDataToLocal = (skipVerify = false) => {

};

const addClass = (selector, ...classname) => {
    [...classname].forEach(name => qs(selector).classList.add(name));
};

const removeClass = (selector, ...classname) => {
    [...classname].forEach(name => qs(selector).classList.remove(name));
};

const show = (selector, disp = 'flex') => {
    qs(selector).style.display = disp;
};

const hide = (...selectors) => {
    [...selectors].forEach(sel => qs(sel).style.display = 'none');
};

const disableForm = (formObj, ...additionalSelector) => {
    Array.from(formObj.elements).forEach(elem => elem.disabled = true);
    [...additionalSelector].forEach(sel => qs(sel).disabled = true);
};

const enableForm = (formObj, ...additionalSelector) => {
    Array.from(formObj.elements).forEach(elem => elem.disabled = false);
    [...additionalSelector].forEach(sel => qs(sel).disabled = false);
};

const closeMessagePopup = () => {
    const messageObj = qs('.message-container');
    const type = messageObj.getAttribute('message-type');
    hide('.message-mask', '.message-confirm-button-container', '.message-progress-bar');
    html('.message-body-container');
    removeClass('.message-container', `message-${type}-theme`, 'message-default-cursor', 'message-container-show');
    removeClass('.message-progress-bar', `message-${type}-progress-bar`);
    removeClass('.message-progress-bar-fill', `message-${type}-theme`, 'message-progress-bar-fill-run');
    messageTimer && clearTimeout(messageTimer);  
};

const showMessagePopup = (message, type = 'alert', confirmCallback) => { // type == alert || info || confirm
    const messageSymbol  = `<div class="message-symbol">${svgSource[type]}</div>`;
    html('.message-body-container', `${messageSymbol} <div class="message-body">${message}</div>`);
    attr('.message-container', {'message-type': type});
    addClass('.message-container', `message-${type}-theme`);
    if (type == 'confirm') {
        addClass('.message-container', 'message-default-cursor');
        show('.message-confirm-button-container');
        qs('.message-container').removeEventListener('click', closeMessagePopup);
        if (confirmCallback) {
            confirmCallback.confirmed && qs('.message-confirm').addEventListener('click', confirmCallback.confirmed);
            confirmCallback.cancelled && qs('.message-cancel').addEventListener('click', confirmCallback.cancelled);
        }
    }
    else {
        qs('.message-container').addEventListener('click', closeMessagePopup);
        show('.message-progress-bar', 'block');
        if (autoDismissTimeframe > 0) {
            addClass('.message-progress-bar', `message-${type}-progress-bar`);
            addClass('.message-progress-bar-fill', `message-${type}-theme`);
            setTimeout(() => {
                addClass('.message-progress-bar-fill', 'message-progress-bar-fill-run');
            }, 50);
            qs('.message-progress-bar-fill').style.transition = `width ${autoDismissTimeframe}s ease-out`;
            messageTimer = setTimeout(closeMessagePopup, autoDismissTimeframe * 1000);
        }
    }
    addClass('.message-container', 'message-container-show');
    show('.message-mask');
};

const renderAppMenuContent = (hiddenGroups = []) => {
    const container = qs('.app-menu-content');
    html(container);
    if (hiddenGroups.length > 0) {  
        let addGroupButton;      
        hiddenGroups.forEach(group => {
            if (group.innerHTML == '+') {
                addGroupButton = create('div', '+ Add Group');
                addGroupButton.addEventListener('click', addGroup);                 
            }
            else {
                const index = group.getAttribute('group-index');
                const groupItem = create('div', group.innerHTML, '', {'group-index': index});
                index == homeTabData.current_group && addClass(groupItem, 'group-selected');
                groupItem.addEventListener('click', () => {
                    closeAppMenu();
                    goToGroup(index);
                    setGruopVisibility();
                });
                groupItem.addEventListener('contextmenu', editGroup);
                container.append(groupItem);
            }
        });
        addGroupButton && container.append(addGroupButton); 
        const divider = create('div', '', 'app-menu-divider');
        container.append(divider);        
    }
    const settingsItem = create('div', '&#9900; Settings');
    settingsItem.addEventListener('click', showSettingsPanel);    
    container.append(settingsItem);
};

const renderGroups = () => {
    const groups = homeTabData.groups;
    const container = qs('.group-container');
    html(container);
    container.addEventListener('click', closeAppMenu);
    groups.forEach((group, groupIndex) => {
        const groupItem = create('div', group.name, 'group-label center', {
            id: `group${groupIndex}`,
            'group-index': groupIndex,
            'draggable': true
        });
        groupItem.addEventListener('click', () => {
            closeAppMenu();
            goToGroup(groupIndex);
        });
        groupItem.addEventListener('dragstart', setGroupDrag);
        groupItem.addEventListener('dragend', moveGroup);
        groupItem.addEventListener('contextmenu', editGroup);
        container.append(groupItem);
    });
    const addGroupButton = create('div', '+', 'group-label add-new-group center');
    addGroupButton.addEventListener('click', addGroup);
    container.append(addGroupButton);
    setGruopVisibility();
};

const renderBookmarks = data => {
    const container = qs('.bookmark-container');
    html(container);
    container.addEventListener('click', closeAppMenu);
    data.forEach((bookmark, bookmarkIndex) => {
        const bookmarkItem = create('div', '', 'bookmark-item', {
            id: `bookmark${bookmarkIndex}`,
            draggable: true
        });
        bookmarkItem.addEventListener('click', () => {
            closeAppMenu();
            if (forceOpenInNewTab || (typeof openInNewTab !== 'undefined' && openInNewTab)) {
                forceOpenInNewTab = false;
                setTimeout(() => {
                    window.open(bookmark.url);
                }, 50);
            }
            else {
                top.location.href = bookmark.url;
            }
        });
        bookmarkItem.addEventListener('dragstart', setBookmarkDrag);       
        bookmarkItem.addEventListener('dragend', moveBookmark);         
        bookmarkItem.addEventListener('contextmenu', () => {
            editBookmark(bookmark, bookmarkIndex);
        });
        const bookmarkThumb = create('div', '', 'bookmark-thumbnail');
        const thumbnailSource = bookmark.hasOwnProperty('thumbnail') && bookmark.thumbnail.match(/^(http|https):\/\//i) == null ? `/thumbnail/${bookmark.thumbnail}` : bookmark.thumbnail;
        bookmarkThumb.style.background = `url(${thumbnailSource})`;
        const bookmarkLabel = create('div', bookmark.label, 'bookmark-label');
        bookmarkItem.append(bookmarkThumb, bookmarkLabel);
        container.append(bookmarkItem);
    });
    const addBookmarkButton = create('div', '+', 'bookmark-item add-new-bookmark center');
    addBookmarkButton.addEventListener('click', addBookmark);
    container.append(addBookmarkButton);
};

const goToGroup = (group = 0) => {
    const currentGroup = homeTabData.current_group;
    removeClass(`#group${currentGroup}`, 'group-selected');
    addClass(`#group${group}`, 'group-selected');
    renderBookmarks(homeTabData.groups[group].bookmarks);
    homeTabData.current_group = group;
    setDataToServer();
};

const closeGroupForm = () => {
    groupForm.reset();
    editingMemo.length = 0;
    hide('.popup-mask', '.group-form', '.delete-group-button-container');
    removeClass('.group-form', 'form-container-show');
};

const showGroupForm = () => {
    closeAppMenu();
    const type = getValue('.group-form-index') == -1 ? 'Add' : 'Edit';
    html('.group-form-header', `${type} Group`);
    html('.group-form-submit-button', type == 'Add' ? 'Add' : 'Save');
    show('.popup-mask');
    setTimeout(() => {
        addClass('.group-form', 'form-container-show');
    }, 100);   
    show('.group-form', 'block');
};

const setGroupDrag = event => {
    closeAppMenu();
    const sourceObj = event.target;
    attr(sourceObj, {'starting-point': event.clientX});
    setDragStartState(sourceObj);
};

const moveGroup = event => {
    if (homeTabData.groups.length < 2) return;
    const sourceObj = event.target;
    const sourceIndex = sourceObj.id.slice(5);
    const startingPoint = sourceObj.getAttribute('starting-point');
    const dropPoint = getBoundingProps(sourceObj).x + (event.clientX - startingPoint);
    const groups = homeTabData.groups;
    const newGroups = [];
    let currentGroup = homeTabData.current_group;
    let newIndex = 0;
    let inserted = false;
    const currentGroupName = groups[currentGroup].name;
    setDragEndState(sourceObj);
    groups.forEach((group, index) => {
        if (getBoundingProps(`#group${index}`).x + 10 <= dropPoint) {
            index != sourceIndex && newGroups.push(group);
        }
        else {
            if (!inserted) {
                newGroups.push(groups[sourceIndex]);               
                inserted = true;
            }
            index != sourceIndex && newGroups.push(group);
        }
        newIndex ++;
    });
    if (!inserted) {
        newGroups.push(groups[sourceIndex]);              
        inserted = true;
    }
    const getGroupIndexByName = (groups, name) => {
        let result = 0;
        groups.forEach((group, index) => {
            group.name == name && (result = index);
        });
        return result;
    };
    currentGroup = getGroupIndexByName(newGroups, currentGroupName);
    homeTabData.current_group = currentGroup;
    homeTabData.groups = newGroups;
    renderGroups();
    goToGroup(currentGroup);
};

const editGroup = event => {
    const group = event.target;
    const groupIndex = group.getAttribute('group-index');
    const groupName = group.innerText;
    setFormValues(groupForm, [
        groupIndex,
        groupName
    ]);
    show('.delete-group-button-container');
    editingMemo.push(groupIndex, groupName);
    showGroupForm();
    return false;
};

const addGroup = () => {
    setValue('.group-form-index', -1);
    showGroupForm();
};

const checkExistingGroupName = (groupIndex, groupName) => {
    const groups = homeTabData.groups;
    if (groupIndex != -1 && groups[groupIndex].name == groupName) {
        return false;
    }
    for (let i = 0; i < groups.length; i ++) {
        if (i == groupIndex) continue;
        if (groups[i].name == groupName) {
            return true;
        }
    }
    return false;
};

const submitGroupForm = () => {
    let [groupIndex, groupName] = getFormValues(groupForm);
    if (groupName.trim() !== '') {
        if (!checkExistingGroupName(groupIndex, groupName)) {
            const type = groupIndex == -1 ? 'Add' : 'Edit';
            if (type == 'Add') {
                homeTabData.groups.push({
                    name: groupName,
                    bookmarks: []
                });
                groupIndex = homeTabData.groups.length - 1;
            }
            else {
                homeTabData.groups[groupIndex].name = groupName;
            }
            renderGroups();
            goToGroup(groupIndex);
            setGruopVisibility();
            closeGroupForm();
        }
        else {
            showMessagePopup(`&#34;${groupName}&#34; already exist, please use another name.`);
        }
    }
    else {
        showMessagePopup('Group Name cannot be empty.');
    }
};

const closeBookmarkForm = () => {
    bookmarkForm.reset();
    editingMemo.length = 0;
    uploadBuffer = undefined;
    enableForm(bookmarkForm, '.close-bookmark-form', '.delete-bookmark-button');
    removeClass('.bookmark-form', 'form-disabled', 'bookmark-form-expand');
    hide('.popup-mask', '.bookmark-form', '.delete-bookmark-button-container');
    removeClass('.bookmark-form', 'form-container-show');
};

const showBookmarkForm = () => {
    closeAppMenu();
    const type = getValue('.bookmark-form-index') == -1 ? 'Add' : 'Edit';
    html('.bookmark-form-header', `${type}  Bookmark`);
    html('.bookmark-form-submit-button', type == 'Add' ? 'Add' : 'Save');
    show('.popup-mask');
    setTimeout(() => {
        addClass('.bookmark-form', 'form-container-show');
    }, 100);
    show('.bookmark-form', 'block');
};

const setBookmarkDrag = event => {
    closeAppMenu();
    const sourceObj = event.target;
    attr(sourceObj, {'starting-point': JSON.stringify({
        x: event.clientX,
        y: event.clientY
    })});
    setDragStartState(sourceObj);
};

const findGrooupMoveTo = dropX => {
    const groupObjs = qs('.group-label', true);
    for (let i = 0 ; i < groupObjs.length; i++) {
        const groupProps = getBoundingProps(groupObjs[i]);
        if (dropX >= groupProps.left && dropX <= groupProps.right) {
            return i;
        }
    }
    return null;
};

const moveBookmark = event => {
    const sourceObj = event.target;
    const sourceIndex = sourceObj.id.slice(8);
    const startingPoint = JSON.parse(sourceObj.getAttribute('starting-point'));
    const dropPointX = getBoundingProps(sourceObj).x + (event.clientX - startingPoint.x);
    const dropPointY = getBoundingProps(sourceObj).y + (event.clientY - startingPoint.y);
    const currentGroup = homeTabData.current_group;
    const bookmarks = homeTabData.groups[homeTabData.current_group].bookmarks;
    let newBookmarks = [];
    let increasementY, dropPointFlatX, inserted;
    const bodyWidth = document.body.clientWidth;
    const baseY = getBoundingProps('#bookmark0').bottom;
    const isMoveToGroup = dropPointY < getBoundingProps('.group-container').bottom;
    setDragEndState(sourceObj);
    // move to other group
    if (isMoveToGroup) {
        const sourceBookmark = homeTabData.groups[currentGroup].bookmarks[sourceIndex];
        const groupIndex = findGrooupMoveTo(dropPointX);
        newBookmarks = homeTabData.groups[currentGroup].bookmarks;
        if (currentGroup != groupIndex) {
            if (!checkExistingBookmarkLabel(groupIndex, -1, sourceBookmark.label)) {
                homeTabData.groups[groupIndex].bookmarks.push({
                    label: sourceBookmark.label,
                    url: sourceBookmark.url,
                    thumbnail: sourceBookmark.thumbnail
                });
                newBookmarks = homeTabData.groups[currentGroup].bookmarks.filter((bookmark, index) => index != sourceIndex);
            }
            else {
                showMessagePopup(`&#34;${sourceBookmark.label}&#34; already exist in &#34;${homeTabData.groups[groupIndex].name}&#34; group.`);
            }
        }
    }
    else {
        bookmarks.forEach((bookmark, index) => {
            const bookmarkPosition = getBoundingProps(`#bookmark${index}`);
            let bookmarkFlatX = bookmarkPosition.x;
            if (bookmarkPosition.bottom != baseY) {
                if (!increasementY) {
                    increasementY = bookmarkPosition.bottom - baseY;
                }
                bookmarkFlatX = (bodyWidth * ((bookmarkPosition.bottom - baseY) / increasementY)) + bookmarkPosition.x;
            }
            if (dropPointY < baseY) {
                dropPointFlatX = dropPointX;
            }
            else {
                dropPointFlatX = (bodyWidth * Math.floor(dropPointY / baseY)) + dropPointX;
            }
            if (bookmarkFlatX <= dropPointFlatX) {
                if (index != sourceIndex) {
                    newBookmarks.push(bookmark);
                }
            }
            else {
                if (!inserted) {
                    newBookmarks.push(bookmarks[sourceIndex]);               
                    inserted = true;
                }
                if (index != sourceIndex) {
                    newBookmarks.push(bookmark);
                }
            }        
        });
        if (!inserted) {
            newBookmarks.push(bookmarks[sourceIndex]);              
            inserted = true;
        }
    }
    if (isMoveToGroup || newBookmarks.length > 0) {
        homeTabData.groups[currentGroup].bookmarks = newBookmarks;
        renderBookmarks(newBookmarks);
        setDataToServer();
    }
};

const editBookmark = (bookmark, bookmarkIndex) => {
    const bookmarkLabel = bookmark.label;
    const bookmarkUrl = bookmark.url;
    const bookmarkThumbnail = bookmark.thumbnail;
    setFormValues(bookmarkForm, [
        bookmarkIndex,
        bookmarkUrl,
        bookmarkLabel,
        '',
        ''
    ]);
    show('.delete-bookmark-button-container');
    editingMemo.push(bookmarkIndex, bookmarkLabel, bookmarkUrl, bookmarkThumbnail);
    switchReloadThumbnailType();
    showBookmarkForm();
    return false;
};

const addBookmark = () => {
    setValue('.bookmark-form-index', -1);
    switchReloadThumbnailType('favicon');
    showBookmarkForm();
};

const initThumbnailUploader = () => {
    setDropArea('thumbnail')
};

const switchReloadThumbnailType = (type = '') => {
    uploadBuffer = undefined;
    const buttons = qs('.thumbnail-options button', true);
    buttons.forEach(elem => {
        elem.innerText.toLowerCase() == type ?
        addClass(elem, 'thumbnail-type-selected') :
        removeClass(elem, 'thumbnail-type-selected');
    });
    if (type == '') {
        hide('.thumbnail-custom-url', '.thumbnail-upload-container');
        removeClass('.bookmark-form', 'bookmark-form-small-expand', 'bookmark-form-full-expand');
    }
    else if (type == 'upload') {
        hide('.thumbnail-custom-url');
        show('.thumbnail-upload-container');
        addClass('.bookmark-form', 'bookmark-form-small-expand');
        addClass('.bookmark-form', 'bookmark-form-full-expand');
        initThumbnailUploader();
    }
    else {
        attr('.thumbnail-custom-url', {placeholder: `Option: Get ${type} from this url instead`});
        hide('.thumbnail-upload-container');
        show('.thumbnail-custom-url');
        removeClass('.bookmark-form', 'bookmark-form-full-expand');
        addClass('.bookmark-form', 'bookmark-form-small-expand');
    }
    setValue('.bookmark-thumbnail-type', type);
};

const checkExistingBookmarkLabel = (groupIndex, bookmarkIndex, bookmarkLabel) => {
    const bookmarks = homeTabData.groups[groupIndex].bookmarks;
    if (bookmarkIndex != -1 && bookmarks[bookmarkIndex].label == bookmarkLabel) {
        return false;
    }
    for (let i = 0; i < bookmarks.length; i ++) {
        if (i == bookmarkIndex) continue;
        if (bookmarks[i].label == bookmarkLabel) {
            return true;
        }
    }
    return false;
}; 

const submitBookmarkForm = () => {
    const currentGroup = homeTabData.current_group;
    const [bookmarkIndex, bookmarkUrl, bookmarkLabel, bookmarkThumbnailType, bookmarkThumbnailCUrl]= getFormValues(bookmarkForm);  
    if (bookmarkLabel.trim() !== '' && bookmarkUrl.trim() !== '') {        
        if (!checkExistingBookmarkLabel(currentGroup, bookmarkIndex, bookmarkLabel)) {
            if (bookmarkThumbnailType == 'upload' && typeof uploadBuffer !== 'string') {
                showMessagePopup('Please select a file to upload.');
                return false;
            }
            const submitType = bookmarkIndex == -1 ? 'Add' : 'Edit';
            let shouldReloadThumbnail = true;
            if (submitType == 'Edit') {
                const targetDataBlock = homeTabData.groups[currentGroup].bookmarks[bookmarkIndex];
                if (targetDataBlock.url == bookmarkUrl && bookmarkThumbnailType == '') {
                    shouldReloadThumbnail = false;
                }
            }
            const updateBookmark = filename => {
                const bookmarks = homeTabData.groups[currentGroup].bookmarks;
                let newIndex;
                if (bookmarkIndex == -1) {
                    newIndex = bookmarks.length;
                    bookmarks[newIndex] = {};
                }
                else newIndex = bookmarkIndex;
                bookmarks[newIndex].label = bookmarkLabel;
                bookmarks[newIndex].url = bookmarkUrl;
                if (filename) {
                    bookmarks[newIndex].thumbnail = filename;
                }
                goToGroup(currentGroup); 
                closeBookmarkForm();
            };
            if (shouldReloadThumbnail) {
                html('.bookmark-form-submit-button', svgSource.loading);
                disableForm(bookmarkForm, '.close-bookmark-form', '.delete-bookmark-button');
                const deleteThumbnail = editingMemo.length > 0 ? editingMemo[3] : '';
                const thumbnailSourceUrl = bookmarkThumbnailType != 'upload' && bookmarkThumbnailCUrl != '' ? bookmarkThumbnailCUrl : bookmarkUrl;
                const formData = new FormData();
                formData.append('url', bookmarkUrl);
                formData.append('thumbnail_type', bookmarkThumbnailType);
                formData.append('thumbnail_url', thumbnailSourceUrl);
                formData.append('thumbnail_delete', deleteThumbnail);
                formData.append('upload_buffer', uploadBuffer);
                fetch('/create-thumbnail/', {
                    method: 'POST',
                    header: {'Content-Type': 'multipart/form-data'},
                    body: formData
                })
                .then(resp => resp.json())
                .then(data => {
                    if (data.message) {
                        showMessagePopup(data.message);
                    }
                    updateBookmark(data.filename);
                });
            }
            else updateBookmark();
        }
        else {
            showMessagePopup(`&#34;${bookmarkLabel}&#34; already exist, please use another label.`);
        }    
    }
    else {
        showMessagePopup('URL and Label cannot be empty.');
    }
};

const cancelDeleteItem = () => {
    closeMessagePopup();
};

const preceedDeleteItem = () => {
    let currentGroup = homeTabData.current_group;
    const [itemIndex, , , bookmarkThumbnail] = editingMemo;
    const isGroup = editingMemo.length == 2;
    if (isGroup) {
        const groupHolder = homeTabData.groups.filter((group, index) => index != itemIndex);
        homeTabData.groups = groupHolder;
        itemIndex == currentGroup && (currentGroup = 0);
        itemIndex < currentGroup && (currentGroup = currentGroup - 1);
        homeTabData.current_group = currentGroup;
        renderGroups();
        goToGroup(currentGroup);
        closeGroupForm();
        closeMessagePopup();
    }
    else {
        const formData = new FormData();
        formData.append('thumbnail_delete', bookmarkThumbnail);
        fetch('/delete-thumbnail/', {
            method: 'POST',
            header: {'Content-Type': 'multipart/form-data'},
            body: formData
        })               
        .then(resp => {
            if (resp.ok) {
                const bookmarkHolder = homeTabData.groups[currentGroup].bookmarks.filter((bookmark, index) => index != itemIndex);
                homeTabData.groups[currentGroup].bookmarks = bookmarkHolder;
                goToGroup(currentGroup);
                closeBookmarkForm();
                closeMessagePopup();
            }
        })
        .catch(error => {
            showMessagePopup('Error, please try again later.');
            closeBookmarkForm();
            closeMessagePopup();
        });
    }
};

const deleteItem = () => {
    const [ , itemNameLabel] = editingMemo;
    const isGroup = editingMemo.length == 2;
    if (isGroup && homeTabData.groups.length == 1) {
        showMessagePopup('You need at least one group for bookmarks.');
        return false;
    }
    let message = `Do you want to delete &#34;${itemNameLabel}&#34;?`;
    isGroup && (message += '<br/>This will also remove bookmarks in this group.');
    showMessagePopup(message, 'confirm', {
        confirmed: preceedDeleteItem,
        cancelled: closeMessagePopup
    });
};

const convertSpeedDialsData = (data) => {
    const htbData = {
        current_group: 0,
        groups: []
    };
    const groupMap = [];
    data.groups.forEach(group => {
        const htbGroups = htbData.groups;
        groupMap.push(group.id);
        htbGroups.push({
            name: group.title,
            bookmarks: []
        });
    });
    data.dials.forEach(dial => {
        let groupIndex = 0;
        for (let i = 0; i < groupMap.length; i++) {
            if (groupMap[i] == dial.idgroup) groupIndex = i;
        }
        const bookmarks = htbData.groups[groupIndex].bookmarks;
        bookmarks.length = Math.max(bookmarks.length, dial.position + 1);
        bookmarks[dial.position] = {
            label: dial.title,
            url: dial.url
        };
    });
    htbData.groups.forEach(group => {
        const cleanBookmarks = group.bookmarks.filter(bookmark => bookmark.label != '' && bookmark.url != '');
        group.bookmarks = cleanBookmarks;
    });
    return htbData;
};

const convertBrowserData = (data) => {
    const htbData = {
        current_group: 0,
        groups: [{
                name:"Home",
                bookmarks:[]
            }]
        };
    const groups = htbData.groups;
    const dataLines = Array.from(data.split('\n'));
    let grouplevelMap = [0];
    let currentLevel = 0;
    dataLines.forEach(line => {
        line = line.trim();
        if (line.match(/(<H3)\s/) != null) {
            const folderName = line.split('>')[1].split('<')[0];
            groups.push({
                name: folderName,
                bookmarks: []
            });
            currentLevel++;
            grouplevelMap.push(currentLevel);
        }
        if (line.match(/(<A)\s/) != null) {
            const bookmarkLabel = line.split('>')[1].split('<')[0];
            const bookmarkUrl = line.split('HREF="')[1].split('"')[0];
            const targetIndex = currentLevel == 0 ? 0 : grouplevelMap.lastIndexOf(currentLevel);
            groups[targetIndex].bookmarks.push({
                label: bookmarkLabel,
                url: bookmarkUrl
            });
        }
        if (line.match(/(<\/DL>)/) != null) {
            currentLevel --;
        }
    });
    return htbData;
};

const isHomeTabBookmarkData = data => {
    data = data.hasOwnProperty('home_tab_data') ? data.home_tab_data : data;
    return data.hasOwnProperty('current_group') && data.hasOwnProperty('groups');
};

const isSpeedDialsData = data => {
    return data.hasOwnProperty('dials') && data.hasOwnProperty('groups');
};

const isNetscapeBookmarkData = data => {
    return data.match(/(NETSCAPE-Bookmark-file|<\/DL>|<A HREF)/i) != null;
};

const importData = files => {
    const uploadFile = files[0];    // only handle the first file
    const dataType = uploadFile.type.split('/')[1];
    const reader = new FileReader();
    reader.onload = async event => {
        try {
            const fileContent = event.target.result;
            const importedData = dataType == 'json' ? JSON.parse(fileContent) : fileContent;
            const isNetscapeBookmark = dataType == 'html' && isNetscapeBookmarkData(importedData);
            const isSpeedDials = dataType == 'json' && isSpeedDialsData(importedData);
            const isHomeTabBookmark = dataType == 'json' && isHomeTabBookmarkData(importedData);
            if (isNetscapeBookmark || isSpeedDials || isHomeTabBookmark) {
                homeTabData = isNetscapeBookmark ? convertBrowserData(importedData) :
                    (isSpeedDials ? convertSpeedDialsData(importedData) : importedData.home_tab_data);
                renderGroups();
                goToGroup(homeTabData.current_group);
                showMessagePopup('Data import successfully.', 'info');
            }
            else {
                showMessagePopup('Invalid file format.');
            }
        }
        catch (error) {
            showMessagePopup('Error, please try again later.');
        }
    };
    reader.readAsText(uploadFile);
};

const initImportUploader = () => {
    setDropArea('import');
};

const applyBackground = (type = 'apply') => {
    if (type == 'apply' && typeof uploadBuffer !== 'string') {
        showMessagePopup('Please select a file to upload.');
        return false;
    }
    html('#background_action_button', svgSource.loading);
    qs('#background_action_button').disabled = true;
    const formData = new FormData();
    formData.append('home_tab_data', `{"home_tab_data":${JSON.stringify(homeTabData)}}`);
    type == 'apply' && formData.append('upload_buffer', uploadBuffer);
    fetch('/set-background/', {
        method: 'POST',
        header: {'Content-Type': 'multipart/form-data'},
        body: formData
    })
    .then(resp => resp.json())
    .then(data => {
        if (data.hasOwnProperty('home_tab_data')) {
            homeTabData = data.home_tab_data;
            if (homeTabData.hasOwnProperty('background_image')) {
                document.body.style.backgroundImage = `url(${homeTabData.background_image})`;
                showMessagePopup(`Background image ${type == 'apply' ? 'applied' : 'removed'}.`, 'info');
                html('#background_action_button', type == 'apply' ? 'Remove' : 'Apply');
                qs('#background_action_button').disabled = false;
                cleanUploadBuffer();
            }
        }
        else {
            showMessagePopup(data.message);
        }
    });
};

const preceedRemoveBackground = () => {
    qs('.drop-area-container').style.backgroundImage = '';
    homeTabData.background_image = '';
    applyBackground('remove');
    closeMessagePopup();
};

const removeBackground = () => {
    showMessagePopup('Do you want to remove background image?', 'confirm', {
        confirmed: preceedRemoveBackground,
        cancelled: closeMessagePopup
    });
};

const applyBackgroundChanges = () => {
    const type = qs('#background_action_button').innerHTML;
    type == 'Apply' ? applyBackground() : removeBackground();
}

const previewImage = files => {
    let reader = new FileReader();
    reader.readAsDataURL(files[0]);
    reader.onloadend = () => {
        uploadBuffer = reader.result;
        qs('.drop-area-container').style.backgroundImage = `url(${reader.result})`;
    };
};

const verifyDrop = (files) => {
    const acceptedFormat = qs('.drop-area-file-input').getAttribute('accept');
    const uploadFile = files[0];
    if (!acceptedFormat.split(',').includes(uploadFile.type)) {
        showMessagePopup('Invalid file format.');
    }
    else {
        const type = qs('.drop-area-file-input').getAttribute('upload-type');
        if (type == 'import') {
            importData(files);
        }
        else if (type == 'thumbnail' || type == 'background') {
            previewImage(files);
        }
    }
};

const cleanUploadBuffer = () => {
    dropAreaForm.reset();
    uploadBuffer = undefined;
};

const resetDropArea = () => {
    ['import', 'thumbnail', 'background'].forEach(container => {
        html(`.${container}-upload-container`);
    });
    cleanUploadBuffer();
};

const setDropArea = (type) => { // import / thumbnail / background
    resetDropArea();
    const acceptedFormat = type == 'import' ? 'application/json,text/html' : 'image/png,image/jpeg';
    const dropAreaCode = qs('.drop-area-mock').innerHTML.replace(/-mock/g, '');
    const targetSelector = `.${type}-upload-container`;
    html(targetSelector, dropAreaCode);
    attr('.drop-area-file-input', {
        accept: acceptedFormat,
        'upload-type': type
    });
    const dropArea = qs('.drop-area-container');
    qs('.drop-area-container').style.backgroundImage = type == 'background' ? `url(${homeTabData.background_image})` : '';
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
        dropArea.addEventListener(evt, event => {
            event.preventDefault();
            event.stopPropagation();
        });
    });
        
    ['dragenter', 'dragover'].forEach(evt => {
        dropArea.addEventListener(evt, () => {
            addClass('.drop-area-container', 'dragging-in');
        });
    });
        
    ['dragleave', 'drop'].forEach(evt => {
        dropArea.addEventListener(evt, () => {
            removeClass('.drop-area-container', 'dragging-in');
        });
    });
    dropArea.addEventListener('drop', event => {
        const dt = event.dataTransfer;
        const files = dt.files;
        verifyDrop(files);
    }, false);
    closeAppMenu();
    show('.popup-mask');
    show(targetSelector, 'block');
};

const getAPIKey = () => {
    const formData = new FormData();
    fetch('/get-apikey/')    
    .then(resp => resp.json())
    .then(data => {
        apikey = data.apikey;
        qs('.api-key-field').value = apikey;
    })
    .catch(error => {
        showMessagePopup('Unable to get api key, please try again later.');
    });    
};

const setSettings = (applyToForm = true) => {
    rememberGroupIndex = homeTabData.hasOwnProperty('remember_group_index') ? homeTabData.remember_group_index : true;
    openInNewTab = homeTabData.hasOwnProperty('open_in_new_tab') ? homeTabData.open_in_new_tab : false;
    autoDismissTimeframe = homeTabData.hasOwnProperty('auto_dismiss_timeframe') ? parseInt(homeTabData.auto_dismiss_timeframe) : 5;
    maxBookmarkPerRow = homeTabData.hasOwnProperty('max_bookmark_per_row') ? parseInt(homeTabData.max_bookmark_per_row) : 6;
    const appBackgroundImage = homeTabData.hasOwnProperty('background_image') ? homeTabData.background_image : '';
    appBackgroundImage != '' && (document.body.style.backgroundImage = `url(${appBackgroundImage})`);
    const colorScheme = homeTabData.hasOwnProperty('color_scheme') ? homeTabData.color_scheme : 'light_dark';
    if (applyToForm) {
        qs('#remember_group_index').checked = rememberGroupIndex;
        qs('#open_in_new_tab').checked = openInNewTab;
        qs('#auto_dismiss_timeframe').value = autoDismissTimeframe;
        qs('#max_bookmark_per_row').value = maxBookmarkPerRow;
        qs(`#color_scheme_${colorScheme}`).checked = true;
    }
    setBookmarkContainer();
};

const saveSettings = (id, ...value) => {
    const [val] = value;
    if (id.match(/(color_scheme_)/) != null) {
        homeTabData.color_scheme = id.replace(/color_scheme_/, '');
    }
    if (['remember_group_index', 'max_bookmark_per_row', 'open_in_new_tab', 'auto_dismiss_timeframe'].indexOf(id) != -1) {
        homeTabData[id] = val;
    }
    setSettings(false);
    setDataToServer();
};

const registSettingsEvents = () => {
    qs('.close-settings-panel').addEventListener('click', closeSettingsPanel);
    qs('input[type="checkbox"]', true).forEach(obj => {
        obj.addEventListener('click', event => {
            saveSettings(event.target.id, event.target.checked);
        });
    });
    qs('input[type="radio"]', true).forEach(obj => {
        obj.addEventListener('click', event => {
            saveSettings(event.target.id, event.target.checked);
        });
    });
    qs('input[type="number"]', true).forEach(obj => {
        obj.addEventListener('change', event => {
            saveSettings(event.target.id, event.target.value);
        });
    });    
    qs('.settings-button', true).forEach(obj => {
        obj.addEventListener('click', event => {
            const objId = event.target.id;
            switch(event.target.id) {
                case 'export_data':
                    getDataFromServer();
                    break;
                case 'background_action_button':
                    applyBackgroundChanges();
                    break;                   
                default:
                    return false;
            }
        });
    });       
}

const goToSettingSection = section => {
    settingsMenuItem.forEach(item => {
        item == section ? addClass(`.settings-menu-item-${item}`, 'settings-menu-selected') : removeClass(`.settings-menu-item-${item}`, 'settings-menu-selected');
        item == section ? show(`.settings-${item}`, 'block') : hide(`.settings-${item}`);
    });
    ['appearance', 'data-management'].includes(section) && setDropArea(section == 'appearance' ? 'background' : 'import');
    if (section == 'appearance') {
        html('#background_action_button', !homeTabData.background_image || homeTabData.background_image == '' ? 'Apply' : 'Remove');
    }
    if (section == 'api-key' && !apikey) {
        getAPIKey();
    }
};

const closeSettingsPanel = () => {
    resetDropArea();
    hide('.popup-mask', '.settings-panel');
};

const showSettingsPanel = () => {
    closeAppMenu();
    show('.popup-mask');
    setTimeout(() => {
        addClass('.settings-panel', 'form-container-show');
    }, 100);
    show('.settings-panel', 'block');
    goToSettingSection(settingsMenuItem[0]);
};

const closeAppMenu = () => {
    qs('.app-menu-content').getAttribute('displayed') == 'true' && toggleAppMenu();
};

const toggleAppMenu = () => {
    const menuContentDiv = qs('.app-menu-content');
    let displayed = menuContentDiv.getAttribute('displayed') == 'true';
    displayed ? removeClass('.app-menu-container', 'app-menu-container-show') : addClass('.app-menu-container', 'app-menu-container-show');
    displayed ? removeClass(menuContentDiv, 'app-menu-content-expand') : addClass(menuContentDiv, 'app-menu-content-expand');
    attr(menuContentDiv, {displayed: (!displayed).toString()});
};

const setBookmarkContainer = () => {
    const bookmarkPerRow = Math.min(Math.floor((window.innerWidth + 17) / bookmarkSpace), maxBookmarkPerRow);
    qs('.bookmark-container').style.maxWidth = `${bookmarkSpace * bookmarkPerRow}px`;
    qs('.bookmark-container').style.minWidth = `${bookmarkSpace * bookmarkPerRow}px`;
};

const handleKeyPressed = event => {
    if (event.key == 'Escape') {
        if (qs('.message-mask').style.display != 'none' && qs('.message-mask').style.display != '') {
            closeMessagePopup();
        }
        else {
            if (qs('.popup-mask').style.display != 'none') {
                closeGroupForm();
                closeBookmarkForm();
                closeSettingsPanel();
            }
        } 
        closeAppMenu();
    }
    event.key == 'Shift' && (forceOpenInNewTab = true);
};

const handleKeyReleased = event => {
    event.key == 'Shift' && (forceOpenInNewTab = false); 
};

const renderHTMLElements = () => {
    // thumbnail option buttons
    const buttonContainer = qs('.thumbnail-options');
    ['favicon', 'screenshot', 'upload'].forEach(btn => {
        const button = create('button', `${btn.charAt(0).toUpperCase()}${btn.slice(1)}`);
        button.addEventListener('click', (event) => {
            event.preventDefault();
            switchReloadThumbnailType(btn);
        });
        buttonContainer.append(button);
    });
    // delete button
    ['bookmark', 'group'].forEach(item => {
        html(qs(`.delete-${item}-button`), `${svgSource.delete}<span>Delete ${item}</span>`);
    });
};

const registElementPbjects = () => {
    [groupForm, bookmarkForm, dropAreaForm] = document.forms;
};

const registEvents = () => {
    // regist document events
    ['contextmenu', 'dragover', 'dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => document.addEventListener(evt, event => event.preventDefault()));
    document.addEventListener('keydown', handleKeyPressed);
    document.addEventListener('scroll', closeAppMenu);
    document.addEventListener('visibilitychange', () => {forceOpenInNewTab = false});
    // regist html elemet event
    registSettingsEvents();
    groupForm.addEventListener('submit', event => {
        event.preventDefault();
        submitGroupForm();
    });
    bookmarkForm.addEventListener('submit', event => {
        event.preventDefault();
        submitBookmarkForm();
    });
    qs('.app-menu-icon').addEventListener('click', toggleAppMenu);
    settingsMenuItem.forEach(item => {
        qs(`.settings-menu-item-${item}`).addEventListener('click', () => {
            goToSettingSection(item);
        });
    });
    qs('.delete-button', true).forEach(icon => icon.addEventListener('click', deleteItem));
    qs('.close-group-form').addEventListener('click', event => {
        event.preventDefault();
        closeGroupForm();
    });
    qs('.close-bookmark-form').addEventListener('click', event => {
        event.preventDefault();
        closeBookmarkForm();
    });
    qs('.drop-area-file-input').addEventListener('change', event => verifyDrop(event.target.files));
    // regist window event   
    window.addEventListener('resize', () => {
        setGruopVisibility();
        setBookmarkContainer();
    });
};

const setBookmarkSpace = () => {
    const bookmarkObj = qs('.bookmark-item', true).length > 1 ? qs('#bookmark0') : qs('.add-new-bookmark');
    const bookmarkSpec = getComputedStyle(bookmarkObj);
    const bookmarkWidth = parseInt(bookmarkSpec.width);
    const bookmarkMargin = parseInt(bookmarkSpec.margin);
    const bookmarkBorder = parseInt(bookmarkSpec.border);
    bookmarkSpace = bookmarkWidth + ((bookmarkMargin + bookmarkBorder) * 2);
};

const doneInit = () => {
    setSettings();
    renderGroups();
    goToGroup(rememberGroupIndex ? homeTabData.current_group : 0);
    setBookmarkSpace();
    renderHTMLElements();
    registElementPbjects();
    registEvents();
    html('.app-name', appName);
    html('.app-version', `Version: ${version}`);
    setGruopVisibility();
    setBookmarkContainer();
};

// ejs variables and includes
const appName='<%=appName%>';
const version='<%=version%>';
const svgSource = {
    loading: '<%- include ("svg/loading.svg") %>',
    info: '<%- include ("svg/information.svg") %>',
    confirm: '<%- include ("svg/question_mark.svg") %>',
    alert: '<%- include ("svg/alert.svg") %>',
    delete: '<%- include ("svg/delete.svg") %>'
};
// end of ejs

document.addEventListener('DOMContentLoaded', getDataFromServer);